*ATTENTION*
vloopback-0.90 has some trouble in pipe creation and signal handling.
The following patch to vloopback-0.90 seems to solve the problem quite
effectively. Be aware that it is a very unofficial patch.

The following patch is *not* for vloopback-0.83 or later.
We recommend you to use vloopback-0.90, but if you want to use vloopback-0.83,
please read 'README.vloopback83'.

This patche is based on Anderr Zaja's patch posted to Motion mailing list,
and Tilmann Bitterberg's patch from http://tibit.org/video/#vloop.

-- cut --
diff -ruN vloopback-0.90.orig/Makefile vloopback-0.90/Makefile
--- vloopback-0.90.orig/Makefile	Fri Jun 29 23:52:06 2001
+++ vloopback-0.90/Makefile	Sun Mar 31 01:19:41 2002
@@ -1,16 +1,46 @@
-# Makefile for vloopback
-#
-LINUXSRC=/usr/src/linux
+# The most part of patch is taken from bttv's Makefile.
+#################################################
+# config
 
-# -DFAKE_VIDEO_PROC
-#CONFIG_FLAGS=
-CONFIG_FLAGS= -DCONFIG_PROC_FS -DCONFIG_VIDEO_PROC_FS
+# where the kernel sources are located
+RUNNING := /lib/modules/$(shell uname -r)/build
+KERNEL_DIR := $(shell if test -d $(RUNNING); then echo $(RUNNING); else echo /usr/src/linux; fi)
+#KERNEL_DIR := /usr/src/linux
 
-CFLAGS=	-D__KERNEL__ -DMODULE $(CONFIG_FLAGS) -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing -pipe -fno-strength-reduce -m486 -malign-loops=2 -malign-jumps=2 -malign-functions=2 -I $(LINUXSRC)/drivers/usb -I$(LINUXSRC)/include 
+# kernel version
+CURRENT := $(shell grep "UTS_RELEASE" $(KERNEL_DIR)/include/linux/version.h | cut -d'"' -f2)
+TREE := $(shell echo $(CURRENT) | cut -d. -f1,2)
 
-all:	vloopback.o
+MODULE_DIR := $(shell test -d "/lib/modules/$(CURRENT)/kernel" && \
+	echo "/lib/modules/$(CURRENT)/kernel/drivers/media/video" ||\
+	echo "/lib/modules/$(CURRENT)/misc")
 
-vloopback.o : vloopback.c
+
+#################################################
+# some magic for using linux kernel settings
+# when compiling module(s)
+
+# for new-style kernel Makefiles (2.4)
+export-objs	:= 
+list-multi	:= vloopback.o
+obj-m		:= vloopback.o
+multi-m		:= $(filter $(list-multi), $(obj-m))
+int-m		:= $(sort $(foreach m, $(multi-m), $($(basename $(m))-objs)))
+
+# for old-style kernel Makefiles (2.2)
+M_OBJS		:= $(sort $(filter-out $(export-objs), $(obj-m)))
+MX_OBJS		:= $(sort $(filter     $(export-objs), $(obj-m)))
+MI_OBJS		:= $(sort $(filter-out $(export-objs), $(int-m)))
+MIX_OBJS        := $(sort $(filter     $(export-objs), $(int-m)))
+
+here:
+	DIR=`pwd`; (cd $(KERNEL_DIR); make SUBDIRS=$$DIR modules)
+	@echo
+
+install:
+	su -c "set -x; mkdir -p $(MODULE_DIR); cp -v $(M_OBJS) $(MX_OBJS) $(MODULE_DIR); depmod -a"
+
+include $(KERNEL_DIR)/Rules.make
 
 clean:
 	rm -f *.o *~
diff -ruN vloopback-0.90.orig/vloopback.c vloopback-0.90/vloopback.c
--- vloopback-0.90.orig/vloopback.c	Fri Jun 29 23:52:06 2001
+++ vloopback-0.90/vloopback.c	Sun Aug 18 11:51:03 2002
@@ -50,7 +50,7 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/wrapper.h>
 #include <linux/module.h>
@@ -59,6 +59,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 
+#define VIDIOCSINVALID	_IO('v',BASE_VIDIOCPRIVATE+1)
 
 /************************************************************
     2.2 support
@@ -105,6 +106,7 @@
 	unsigned int pid;
 	unsigned int zerocopy;
 	unsigned long int ioctlnr;
+	unsigned int invalid_ioctl; /* 0 .. none invalid; 1 .. invalid */
 	unsigned int ioctllength;
 	char *ioctldata;
 	char *ioctlretdata;
@@ -505,7 +507,11 @@
 			kill_proc(loops[nr]->pid, SIGIO, 1);
 			interruptible_sleep_on(&loops[nr]->wait);
 			
-			if (cmd & IOC_IN) {
+			if (loops[nr]->invalid_ioctl) {
+				loops[nr]->invalid_ioctl = 0;
+				return -ENOTTY;
+			}
+			if (cmd & IOC_IN && !(cmd & IOC_OUT)) {
 				if (memcmp(loops[nr]->ioctlretdata, loops[nr]->ioctldata, _IOC_SIZE(cmd))) {
 					return -EINVAL;
 				}
@@ -515,11 +521,15 @@
 				return 0;
 			}
 		} else {
-			if (loops[nr]->ioctlnr!=cmd)
+			if ( (loops[nr]->ioctlnr!=cmd) && (cmd != (VIDIOCSINVALID)))
 				/* wrong ioctl */
 				return 0;
-			if (copy_from_user(loops[nr]->ioctlretdata, arg, loops[nr]->ioctllength))
-				return -EFAULT;
+			if (cmd == VIDIOCSINVALID) {
+				loops[nr]->invalid_ioctl = 1;
+			} else {
+				if (copy_from_user(loops[nr]->ioctlretdata, arg, loops[nr]->ioctllength))
+					return -EFAULT;
+			}
 			if (waitqueue_active(&loops[nr]->wait))
 				wake_up(&loops[nr]->wait);
 			loops[nr]->ioctlnr=-1;
@@ -965,11 +975,14 @@
 
 static int create_pipe(int nr)
 {
+	int devnum = -1;
+
 	loops[nr]= kmalloc(sizeof(struct vloopback_pipe), GFP_KERNEL);
 	loops[nr]->vloopin= kmalloc(sizeof(struct vloopback_device), GFP_KERNEL);
 	loops[nr]->vloopout= kmalloc(sizeof(struct vloopback_device), GFP_KERNEL);
 	loops[nr]->vloopin->pipenr=nr;
 	loops[nr]->vloopout->pipenr=nr;
+	loops[nr]->invalid_ioctl = 0; /* tibit */
 	loops[nr]->buffer=NULL;
 	loops[nr]->width=0;
 	loops[nr]->height=0;
@@ -990,15 +1003,16 @@
 	sprintf(((struct video_device *)loops[nr]->vloopout)->name, "Video loopback %d output", nr);
 	init_waitqueue_head(&loops[nr]->wait);
 	init_MUTEX(&loops[nr]->lock);
-	if (video_register_device(&loops[nr]->vloopin->viddev, VFL_TYPE_GRABBER, nr*2+dev_offset)==-1) {
-	kfree(loops[nr]->vloopin);
+	if (dev_offset > -1) devnum = nr*2+dev_offset;
+	if (video_register_device(&loops[nr]->vloopin->viddev, VFL_TYPE_GRABBER, devnum)==-1) {
 		kfree(loops[nr]->vloopout);
 		kfree(loops[nr]);
 		loops[nr]=NULL;
 		info("error registering device");
 		return -ENODEV;
 	}
-	if (video_register_device(&loops[nr]->vloopout->viddev, VFL_TYPE_GRABBER, nr*2+1+dev_offset)==-1) {
+	if (dev_offset > -1) devnum = nr*2+1+dev_offset;
+	if (video_register_device(&loops[nr]->vloopout->viddev, VFL_TYPE_GRABBER, devnum)==-1) {
 		video_unregister_device(&loops[nr]->vloopin->viddev);
 		kfree(loops[nr]->vloopin);
 		kfree(loops[nr]->vloopout);
@@ -1029,6 +1043,10 @@
 MODULE_PARM_DESC(spares, "Nr of spare pipes that should be created");
 MODULE_PARM(dev_offset, "i");
 MODULE_PARM_DESC(dev_offset, "Prefered offset for video device numbers");
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 10)
+MODULE_LICENSE("GPL");
+#endif
 
 EXPORT_NO_SYMBOLS;
 
