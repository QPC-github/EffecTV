*ATTENTION*
vloopback-0.90 has some trouble in pipe creation and signal handling.
Please apply a patch follows.

The following patch to vloopback-0.90 seems to solve the problem quite
effectively. Be aware that it is a very unofficial patch.

You also need to modify 'config.mk' for vloopback-0.90 or later. Please read
the comment in it.

This patche is based on Anderr Zaja's patch posted to Motion mailing list.

-- cut --
diff -ruN vloopback-0.90.orig/Makefile vloopback-0.90/Makefile
--- vloopback-0.90.orig/Makefile	Fri Jun 29 23:52:06 2001
+++ vloopback-0.90/Makefile	Sun Mar 31 01:19:41 2002
@@ -1,16 +1,46 @@
-# Makefile for vloopback
-#
-LINUXSRC=/usr/src/linux
+# The most part of patch is taken from bttv's Makefile.
+#################################################
+# config
 
-# -DFAKE_VIDEO_PROC
-#CONFIG_FLAGS=
-CONFIG_FLAGS= -DCONFIG_PROC_FS -DCONFIG_VIDEO_PROC_FS
+# where the kernel sources are located
+RUNNING := /lib/modules/$(shell uname -r)/build
+KERNEL_DIR := $(shell if test -d $(RUNNING); then echo $(RUNNING); else echo /usr/src/linux; fi)
+#KERNEL_DIR := /usr/src/linux
 
-CFLAGS=	-D__KERNEL__ -DMODULE $(CONFIG_FLAGS) -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing -pipe -fno-strength-reduce -m486 -malign-loops=2 -malign-jumps=2 -malign-functions=2 -I $(LINUXSRC)/drivers/usb -I$(LINUXSRC)/include 
+# kernel version
+CURRENT := $(shell grep "UTS_RELEASE" $(KERNEL_DIR)/include/linux/version.h | cut -d'"' -f2)
+TREE := $(shell echo $(CURRENT) | cut -d. -f1,2)
 
-all:	vloopback.o
+MODULE_DIR := $(shell test -d "/lib/modules/$(CURRENT)/kernel" && \
+	echo "/lib/modules/$(CURRENT)/kernel/drivers/media/video" ||\
+	echo "/lib/modules/$(CURRENT)/misc")
 
-vloopback.o : vloopback.c
+
+#################################################
+# some magic for using linux kernel settings
+# when compiling module(s)
+
+# for new-style kernel Makefiles (2.4)
+export-objs	:= 
+list-multi	:= vloopback.o
+obj-m		:= vloopback.o
+multi-m		:= $(filter $(list-multi), $(obj-m))
+int-m		:= $(sort $(foreach m, $(multi-m), $($(basename $(m))-objs)))
+
+# for old-style kernel Makefiles (2.2)
+M_OBJS		:= $(sort $(filter-out $(export-objs), $(obj-m)))
+MX_OBJS		:= $(sort $(filter     $(export-objs), $(obj-m)))
+MI_OBJS		:= $(sort $(filter-out $(export-objs), $(int-m)))
+MIX_OBJS        := $(sort $(filter     $(export-objs), $(int-m)))
+
+here:
+	DIR=`pwd`; (cd $(KERNEL_DIR); make SUBDIRS=$$DIR modules)
+	@echo
+
+install:
+	su -c "set -x; mkdir -p $(MODULE_DIR); cp -v $(M_OBJS) $(MX_OBJS) $(MODULE_DIR); depmod -a"
+
+include $(KERNEL_DIR)/Rules.make
 
 clean:
 	rm -f *.o *~
diff -ruN vloopback-0.90.orig/vloopback.c vloopback-0.90/vloopback.c
--- vloopback-0.90.orig/vloopback.c	Fri Jun 29 23:52:06 2001
+++ vloopback-0.90/vloopback.c	Mon Jan 21 03:09:08 2002
@@ -50,7 +50,8 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/malloc.h>
+//#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/wrapper.h>
 #include <linux/module.h>
@@ -505,7 +506,7 @@
 			kill_proc(loops[nr]->pid, SIGIO, 1);
 			interruptible_sleep_on(&loops[nr]->wait);
 			
-			if (cmd & IOC_IN) {
+			if (!(cmd & IOC_OUT)) {
 				if (memcmp(loops[nr]->ioctlretdata, loops[nr]->ioctldata, _IOC_SIZE(cmd))) {
 					return -EINVAL;
 				}
@@ -965,6 +966,8 @@
 
 static int create_pipe(int nr)
 {
+	int devnum = -1;
+
 	loops[nr]= kmalloc(sizeof(struct vloopback_pipe), GFP_KERNEL);
 	loops[nr]->vloopin= kmalloc(sizeof(struct vloopback_device), GFP_KERNEL);
 	loops[nr]->vloopout= kmalloc(sizeof(struct vloopback_device), GFP_KERNEL);
@@ -990,15 +993,16 @@
 	sprintf(((struct video_device *)loops[nr]->vloopout)->name, "Video loopback %d output", nr);
 	init_waitqueue_head(&loops[nr]->wait);
 	init_MUTEX(&loops[nr]->lock);
-	if (video_register_device(&loops[nr]->vloopin->viddev, VFL_TYPE_GRABBER, nr*2+dev_offset)==-1) {
-	kfree(loops[nr]->vloopin);
+	if (dev_offset > -1) devnum = nr*2+dev_offset;
+	if (video_register_device(&loops[nr]->vloopin->viddev, VFL_TYPE_GRABBER, devnum)==-1) {
 		kfree(loops[nr]->vloopout);
 		kfree(loops[nr]);
 		loops[nr]=NULL;
 		info("error registering device");
 		return -ENODEV;
 	}
-	if (video_register_device(&loops[nr]->vloopout->viddev, VFL_TYPE_GRABBER, nr*2+1+dev_offset)==-1) {
+	if (dev_offset > -1) devnum = nr*2+1+dev_offset;
+	if (video_register_device(&loops[nr]->vloopout->viddev, VFL_TYPE_GRABBER, devnum)==-1) {
 		video_unregister_device(&loops[nr]->vloopin->viddev);
 		kfree(loops[nr]->vloopin);
 		kfree(loops[nr]->vloopout);
Binary files vloopback-0.90.orig/vloopback.o and vloopback-0.90/vloopback.o differ
